#!/usr/bin/env cake
;;
;; euler45.clj
;;
;; Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:
;;
;; Triangle Tn=n(n+1)/2     1, 3, 6, 10, 15, ...
;; Pentagonal Pn=n(3n-1)/2  1, 5, 12, 22, 35, ...
;; Hexagonal Hn=n(2n-1)     1, 6, 15, 28, 45, ...
;;
;; It can be verified that T285 = P165 = H143 = 40755.
;; Find the next triangle number that is also pentagonal and hexagonal.


(use '[cbd])
(use '[sage])
;;(require 'clojure.contrib.math)
(require '[clojure.math.numeric-tower :only (permutations)])

;; (def s (sage))
;; (s "T,P,H,n = var('T, P, H,n')")
;; (s "trig = (T == n * (n + 1)/2)")
;; (s "pent = (P == n * (3*n - 1)/2)")
;; (s "hex  = (H == n * (2*n - 1))")
;; (prn (s "solve(trig,n)"))
;; (prn (s "solve(pent,n)"))
;; (prn (s "solve(hex, n)"))
;; "[n == -1/2*sqrt(8*T + 1) - 1/2, n == 1/2*sqrt(8*T + 1) - 1/2]"
;; "[n == -1/6*sqrt(24*P + 1) + 1/6, n == 1/6*sqrt(24*P + 1) + 1/6]"
;; "[n == -1/4*sqrt(8*H + 1) + 1/4, n == 1/4*sqrt(8*H + 1) + 1/4]"

(def tri-numbers (map first (rest(iterate (fn [[n, ith]] [(/ (* ith (+ ith  1)) 2) (inc ith)]) [1 1]))))

(defn tri?  [n] (zero? (rem (+ 1 (Math/sqrt (+ 1 (* 8 n)))) 2)))
(defn pent? [n] (zero? (rem (+ 1 (Math/sqrt (+ 1 (* 24 n)))) 6)))
(defn hex?  [n] (zero? (rem (+ 1 (Math/sqrt (+ 1 (* 8 n)))) 4)))


(defn euler-45 []
  (take 3 (filter #(and (pent? %) (hex? %)) tri-numbers)))
